==================================================
1장 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션
==================================================

--------------------------------------------------
1. 계산 중심 → 데이터 중심 애플리케이션
--------------------------------------------------

* 오늘날 많은 애플리케이션은 계산 중심에서 데이터 중심으로 이동
* CPU 성능은 더 이상 주요 병목이 아님

[더 큰 문제]
- 데이터의 양
- 데이터의 복잡도
- 데이터의 변화 속도


--------------------------------------------------
2. 현대 애플리케이션이 필요로 하는 구성 요소
--------------------------------------------------

많은 애플리케이션들은 다음을 필요로 함

- 데이터베이스
- 캐시
- 검색 색인
- 스트림 처리
  -> 비동기 처리를 위해 다른 프로세스로 메시지 전송
- 일괄 처리
  -> 주기적으로 대량의 누적 데이터를 분석


--------------------------------------------------
3. 단일 도구의 한계
--------------------------------------------------

* 점점 더 많은 애플리케이션이
  단일 도구만으로는 데이터 처리 + 저장 요구사항을 만족시키지 못함

[대응 방식]
- 작업을 단일 도구에서 효율적으로 수행 가능한 task로 분리
- 다양한 도구를 애플리케이션 코드로 연결
- 캐시 계층, 검색 엔진(ElasticSearch, Solr 등)을 목적에 맞게 사용


--------------------------------------------------
4. 소프트웨어 시스템의 3가지 핵심 관점
--------------------------------------------------

[중요 관점]
1) 신뢰성 (Reliability)
2) 확장성 (Scalability)
3) 유지보수성 (Maintainability)


==================================================
신뢰성 (Reliability)
==================================================

--------------------------------------------------
5. 신뢰성이란?
--------------------------------------------------

* 애플리케이션은 사용자가 기대한 기능을 수행해야 함
* 시스템은 다음을 만족해야 함

- 사용자 실수 또는 예상치 못한 사용을 허용
- 예상된 부하와 데이터 양에서 필수 사용 사례 만족
- 허가되지 않은 접근 및 오남용 방지


--------------------------------------------------
6. 하드웨어 결함
--------------------------------------------------

[예시]
- 하드디스크 고장
- RAM 결함
- 대규모 정전
- 네트워크 케이블이 뽑히는 사고


--------------------------------------------------
7. 하드웨어 결함 대응
--------------------------------------------------

[일반적인 방법]
- 디스크: RAID 구성
- 서버: 이중 전원 장치, 핫스왑 CPU
- 데이터센터: UPS, 디젤 발전기


--------------------------------------------------
8. 클라우드 환경의 등장
--------------------------------------------------

* 데이터 양과 계산 요구 증가
* 더 많은 장비 사용 → 하드웨어 결함율 증가

[결과]
- 클라우드 플랫폼(AWS 등) 일반화
- 특정 장비 고장에 의존하지 않는 설계
- 확장성과 유연성 우선


--------------------------------------------------
9. 소프트웨어 내결함성의 필요성
--------------------------------------------------

* 하드웨어 중복만으로는 충분하지 않음

[필요한 기능]
- 시스템 중단 없이 패치 적용
- 장애 장비를 제거하면서 서비스 유지


--------------------------------------------------
10. 소프트웨어 오류
--------------------------------------------------

* 하드웨어 결함과 다른 체계적 오류
* 오히려 시스템 장애를 더 자주 유발

[예시]
- 특정 입력으로 모든 서버 인스턴스가 다운되는 버그
- CPU / 메모리 / 디스크 / 네트워크 자원 고갈
- 느린 응답 또는 잘못된 응답 반환
- 한 구성 요소의 결함이 연쇄 장애로 확산


--------------------------------------------------
11. 소프트웨어 오류 대응 전략
--------------------------------------------------

* 체계적 오류는 즉각적인 해결이 어려움

[도움이 되는 방법]
- 시스템 가정과 상호작용을 신중히 설계
- 빈틈없는 테스트
- 프로세스 격리
- 죽은 프로세스 재시작 허용
- 프로덕션 환경에서 동작 측정
- 모니터링 및 분석


--------------------------------------------------
12. 인적 오류
--------------------------------------------------

* 많은 장애는 사람의 실수에서 발생

[인적 오류를 줄이기 위한 방법]
- 실수를 최소화하는 설계 (좋은 추상화, API, 관리 인터페이스)
- 실제 사용자에게 영향 없는 비프로덕션 샌드박스 제공
- 단위 테스트부터 통합 테스트까지 철저히 수행
- 빠른 롤백이 가능한 환경 구성
- 성능 지표와 오류율 모니터링
- 조작 교육과 실습 시행


==================================================
확장성 (Scalability)
==================================================

--------------------------------------------------
13. 확장성이란?
--------------------------------------------------

* 부하 증가로 인한 성능 저하는 흔한 문제
* 확장성은 단순한 "잘 된다 / 안 된다"의 문제가 아님

[확장성을 논한다는 것]
- 시스템이 커질 때 어떤 선택지가 있는가?
- 증가한 부하를 처리하기 위해 자원을 어떻게 투입할 것인가?


--------------------------------------------------
14. 부하 기술하기
--------------------------------------------------

* 부하는 몇 가지 부하 매개변수로 표현

[예시]
- 초당 요청 수
- 읽기 / 쓰기 비율
- 동시 사용자 수
- 캐시 적중률

* 평균보다 소수의 극단적인 경우가 병목의 원인이 될 수 있음


--------------------------------------------------
15. 성능 지표
--------------------------------------------------

* 일괄 처리 시스템: 처리량 (Throughput)
* 온라인 시스템: 응답 시간 (Response Time)


--------------------------------------------------
16. 지연 시간과 응답 시간
--------------------------------------------------

[응답 시간]
- 클라이언트 관점의 전체 시간
- 네트워크 지연, 큐 지연 포함

[지연 시간]
- 요청이 처리되기를 기다리는 시간


--------------------------------------------------
17. 응답 시간 분포
--------------------------------------------------

* 동일한 요청이라도 응답 시간은 매번 다를 수 있음
* 특이 값(outlier)이 존재

[지연 원인 예시]
- 컨텍스트 스위칭
- 네트워크 패킷 손실
- GC 중단
- 페이지 폴트
- 디스크 I/O 지연


--------------------------------------------------
18. 백분위와 꼬리 지연
--------------------------------------------------

[중앙값]
- 일반 사용자가 얼마나 기다리는지

[상위 백분위]
- 최악의 사용자 경험 파악

* 꼬리 지연 시간(tail latency)은 사용자 경험에 직접적인 영향


--------------------------------------------------
19. 선두 차단 (Head-of-Line Blocking)
--------------------------------------------------

* 서버가 동시에 처리 가능한 작업 수에 제한
* 소수의 느린 요청이 전체 지연을 유발


--------------------------------------------------
20. 확장 방식
--------------------------------------------------

[1) 용량 확장 - Scaling Up]
- 더 강력한 장비로 교체
- 비용 높고 물리적 한계 존재

[2) 규모 확장 - Scaling Out]
- 여러 대의 저렴한 장비 추가
- 비공유(shared-nothing) 아키텍처
- 현대 대규모 시스템의 일반적인 방식


--------------------------------------------------
21. Stateful vs Stateless
--------------------------------------------------

[Stateless]
- 수평 확장 쉬움

[Stateful]
- 데이터 분산 필요
- 설계와 운영이 훨씬 복잡
- 분산 DB가 가장 큰 난제


--------------------------------------------------
22. 분산 시스템에 대한 현실적인 시각
--------------------------------------------------

* 도구와 기술은 성숙했지만 설계는 여전히 어려움
* 대용량 트래픽이 없다면 단일 DB가 더 나을 수도 있음

[결론]
- 검증되지 않은 제품은
  미래 부하 대비보다 빠른 반복과 개선이 더 중요


==================================================
유지보수성 (Maintainability)
==================================================

--------------------------------------------------
23. 유지보수 비용
--------------------------------------------------

* 소프트웨어 비용의 대부분은 유지보수에 사용됨

[유지보수 예]
- 버그 수정
- 운영 및 장애 대응
- 새로운 요구사항 반영
- 기술 채무 상환


--------------------------------------------------
24. 유지보수성을 위한 3가지 원칙
--------------------------------------------------

1) 운용성 (Operability)
2) 단순성 (Simplicity)
3) 발전성 (Evolvability)


--------------------------------------------------
25. 운용성
--------------------------------------------------

[좋은 운영의 책임]
- 시스템 상태 모니터링 및 빠른 복구
- 장애 및 성능 저하 원인 분석
- 보안 패치 및 업데이트
- 변경 사항으로 인한 위험 사전 차단
- 용량 계획
- 배포 및 설정 관리 자동화
- 조직 내 시스템 지식 보존


--------------------------------------------------
26. 단순성: 복잡도 관리
--------------------------------------------------

[복잡도의 증상]
- 상태 공간 증가
- 강한 커플링
- 복잡한 의존성
- 일관성 없는 용어
- 임시방편식 해결책

* 복잡도를 제거하는 최상의 도구는 추상화


--------------------------------------------------
27. 좋은 추상화
--------------------------------------------------

* 내부 구현을 숨기고 깔끔한 인터페이스 제공
* 여러 애플리케이션에서 재사용 가능


--------------------------------------------------
28. 발전성: 변화를 쉽게
--------------------------------------------------

* 요구사항과 비즈니스 우선순위는 계속 변함
* TDD, 리팩토링은 변화에 강한 시스템을 만드는데 도움

[핵심]
- 데이터 시스템 변경 용이성은
  단순함과 추상화에 크게 의존


==================================================
마무리
==================================================

* 신뢰성, 확장성에는 쉬운 해결책이 없다
* 운용성, 단순성, 발전성을 항상 염두에 두고
  시스템을 설계해야 한다
