오늘날 많은 애플리케이션 계산 중심 → 데이터 중심

CPU의 성능은 애플리케이션을 제한하는 요소가 아니며, 더 큰 문제는 보통 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도


많은 애플리케이션들은 다음을 필요로 함

데이터베이스
캐시
검색 색인
스트림 처리 - 비동기 처리를 위해 다른 프로세스로 메시지 보내기
일괄 처리 - 주기적으로 대량의 누적된 데이터를 분석 


점점 더 많은 에플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 과도하고 광범위한 요구사항을 가짐

작업은 단일 도구에서 효율적으로 수행할 수 있는 task 로 나눔
다양한 도구들은 애플리케이션 코드를 이용해 서로 연결
애플리케이션 관리 캐시 계층, 엘라스틱서치, 솔라 등 적절히 사용


대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관점 신뢰성, 확장성, 유지보수성

신뢰성
애플리케이션은 사용자가 기대한 기능을 수행
시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용
시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족
시스템은 허가되지 않은 접근과 오남용 방지


하드웨어 결함
하드디스크 고장, 램에 결함 발생, 대규모 정전 사태, 누군가가 네트워크 케이블을 잘못 뽑는 것과 같은 결함을 말함



대응
각 하드웨어 구성 요소에 중복을 추가하는 방법이 일반적

디스크는 RAID 구성으로 설치할 수 있고 서버는 이중 전원 디바이스와 핫스왑 가능한 cpu 를, 데이터센터는 건전지와 예비 전원용 디젤 발전기를 갖출 수 있음



데이터 양과 애플리케이션의 계산 요구가 늘어나면서 더 많은 애플리케이션이 많은 수의 장비를 사용 => 이와 비례하여 하드웨어 결함율도 증가

→  클라우드 플랫폼(AWS와 같은)이 일반화됨

특정 장비 고장에 의존하지 않도록 설계
확장성, 유연성을 우선시


소프트웨어 내결함성 설계의 필요성
하드웨어 중복만으로 충분치 않음
시스템을 중단하지 않고 패치를 적용하거나 장애 장비를 제거하는 기능의 필요


소프트웨어 오류
하드웨어 결함과 다른 시스템 내 체계적 오류가 있고, 하드웨어 결함보다 오히려 시스템 오류를 더욱 많이 유발하는 경향이 있음.



예시)

잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그

CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스

시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스

한 구성 요소의 작은 결함이 다른 구성 요소의 결함을 야기하고 차례차례 더 많은 결함이 발생하는 연쇄 장애



소프트웨어의 체계적 오류는 신속한 해결책이 없으므로

시스템의 가정과 상호작용에 대해 주의 깊게 생각하기

빈틈없는 테스트

프로세스 격리

죽은 프로세스의 재시작 허용

프로덕션 환경에서 시스템 동작의 측정

모니터링

분석하기

등으로 도움을 줄 수 있음



인적 오류
인적 오류를 줄이기 위해서

오류의 가능성을 최소화하는 방향으로 설계(잘 설계된 추상화, API, 관리 인터페이스)

사람이 가장 많이 실수하는 장소(부분)에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리(실제 데이터를 사용하지만 실제 사용자에게는 영향이 없는 비 프로덕션 샌드박스 제공)

단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트

인적 오류를 빠르고 쉽게 복구할 수 있게 하라(빠르게 롤백 가능한 환경)

성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책 마련

조작 교육과 실습을 시행



확장성
성능 저하를 유발하는 흔한 이유 중 하나는 부하 증가

확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는 데 사용하는 용어지만 시스템에 부여하는 일차원적인 표식이 아님을 주의.

오히려 확장성을 논한다는 것은 "시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?"와 "추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?" 같은 질문을 고려한다는 의미



부하 기술하기
부하는 부하 매개변수라 부르는 몇 개의 숫자로 나타낼 수 있음
가장 적합한 부하 매개변수 선택은 시스템 설계에 따라 달라짐
부하 매개변수로는 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자, 캐시 적중률 등
평균적인 경우가 중요할 수도 있고 소수의 극단적인 경우가 병목 현상의 원인일 수도 있음
성능 기술하기
부하 매개변수를 증가시키고 시스템 자원은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?

부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 늘려야 할까?



하둡같은 일괄 처리 시스템은 보통 처리량(throughput), 온라인 시스템은 서비스 응답 시간(response time)



지연 시간(latency)과 응답 시간(response time)

응답 시간 : 클라이언트 관점에서 본 시간으로, 요청을 처리하는 실제 시간 외에도 네트워크 지연과 큐 지연도 포함

지연 시간 : 요청이 처리되길 기다리는 시간으로, 서비스를 기다리며 휴지(latent) 상태인 시간



클라이언트가 몇 번이고 반복해서 동일한 요청을 하더라도 응답 시간이 매번 다를 수 있음

가끔 꽤 오래 걸리는 특이 값(outlier) 존재

백그라운드 프로세스의 컨텍스트 위치, 네트워크 패킷 손실과 TCP 재전송, 가비지 컬렉션 휴지, 디스크에서 읽기를 강제하는 페이지 폴트, 서버랙의 기계적인 진동이나 다른 여러 원인으로 추가 지연 발생 가능



중앙값 : 사용자가 보통 얼마나 오랫동안 기다려야 하는지 알고 싶다

상위 백분위 : 특이 값이 얼마나 좋지 않은지 알아보려

꼬리 지연 시간(tail latency) : 알려진 상위 백분위 응답 시간은 서비스의 사용자 경험에 직접 영향을 주기 때문에 중요



선두 차단(head-of-line blocking) 현상
서버는 병렬로 소수의 작업만 처리할 수 있기 때문에(예를 들어 CPU 코어 수에 제한됨) 소수의 느린 요청 처리만으로도 후속 요청 처리가 지체됨



실전 백분위
상위 백분위는 단일 최종 사용자 요청의 일부로서 여러 번 호출되는 백엔드 서비스에서 특히 중요
병렬로 호출해도 최종 사용자 요청은 여전히 병렬 호출 중 가장 느린 호출이 완료되길 기다려야 함
부하 대응 접근 방식
확장의 두가지 방식

용량 확장 (Scaling Up, 수직 확장)

더 강력한 장비로 교체해 성능을 높이는 방식.

장비가 비싸고 물리적 한계가 있어 확장에 한계가 존재.



규모 확장 (Scaling Out, 수평 확장)

여러 개의 저렴한 장비를 추가하여 부하를 분산.

‘비공유(shared-nothing)’ 아키텍처를 활용해 여러 서버가 독립적으로 작동.

현대 대규모 시스템의 일반적인 접근 방식.



상태 유지(Stateful) vs 상태 비저장(Stateless)

Stateless 서비스는 서버를 여러 대로 분산하기 쉬움

Stateful 시스템(예: DB)은 데이터를 여러 노드에 분산 저장해야 해 훨씬 복잡

데이터베이스의 분산과 유지 관리가 가장 큰 난제



분산 시스템의 난제

분산 시스템은 도구, 기술 성숙도가 좋아졌지만 여전히 설계가 쉽지 않다.

대용량 데이터·트래픽을 처리하지 않는 경우에는 오히려 단일 DB가 더 나을 수 있음.



결론
검증되지 않은 제품의 경우에 미래를 가정한 부하에 대비해 확장하기보다는 빠르게 반복해서 제품 기능을 개선하는 작업이 좀 더 중요



유지보수성
소프트웨어 비용의 대부분은 초기 개발이 아니라 지속해서 이어지는 유지보수에 들어감
유지보수에는 버그 수정, 시스템 운영 유지, 장애 조사, 새로운 플랫폼 적응, 새 사용 사례를 위한 변경, 기술 채무 상환, 새로운 기능 추가 등이


유지보수성을 위한 소프트웨어 시스템 설계 원칙
운용성 - 원활하게 운용할 수 있게

단순성 - 복잡도를 최대한 제거

발전성 - 쉽게 변경할 수 있게



신뢰성, 확장성을 달성하기 위한 쉬운 해결책은 없다. 그보다 운용성, 단순성, 발전성을 염두에 두고 시스템을 생각하려 노력해야 한다.



운용성
좋은 운영의 책임

시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 서비스를 복원

시스템 장애, 성능 저하 등의 문제의 원인을 추적

보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지

다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단

미래에 발생 가능한 문제를 예측해 문제가 발생하기 전에 해결(예를 들어 용량 계획)

배포, 설정 관리 등을 위한 모범 사례와 도구를 마련

애플리케이션을 특정 플랫폼에서 다른 플랫폼으로 이동하는 등 복잡한 유지보수 태스크를 수행

설정 변경으로 생기는 시스템 보안 유지보수

예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의

개인 인사 이동에도 시스템에 대한 조직의 지식을 보존함

단순성 : 복잡도 관리
복잡도는 다양한 증상으로 나타난다. 상태 공간의 급증, 모듈 간 강한 커플링(tight coupling), 복잡한 의존성, 일관성 없는 명명과 용어, 성능 문제 해결을 목표로 한 해킹, 임시방편으로 문제를 해결한 특수 사례 등이 이런 증상

→ 복잡도를 제거하기 위한 최상의 도구는 추상화



좋은 추상화
깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있음 
다른 다양한 어플리케이션에서도 사용 가능
발전성 : 변화를 쉽게
시스템의 요구사항은 끊임없이 변하고, 비즈니스 우선순위가 바뀌고 사용자가 새로운 기능을 요청

애자일 커뮤니티는 TDD와 리팩토링 같이 자주 변화하는 환경에서 소프트웨어를 개발할 때 도움이 되는 기술 도구와 패턴을 개발

데이터 시스템 변경을 쉽게 하고 변화된 요구사항에 시스템을 맞추는 방법은 시스템의 간단함과 추상화와 밀접한 관련




