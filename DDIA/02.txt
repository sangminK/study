==================================================
2장 데이터 모델과 질의 언어
==================================================

--------------------------------------------------
0. 데이터 모델의 중요성
--------------------------------------------------

* 데이터 모델은 소프트웨어 개발에서 가장 중요한 부분 중 하나
* 단순히 "어떻게 구현했는가"뿐 아니라
  "문제를 어떻게 바라보는가"에 큰 영향을 줌


==================================================
관계형 모델과 문서 모델
==================================================

--------------------------------------------------
1. 관계형 모델
--------------------------------------------------

* 오늘날 가장 널리 알려진 데이터 모델
* 에드가 코드(Edgar Codd)가 제안

[기본 개념]
- 데이터는 관계(relation)로 구성 (SQL의 테이블)
- 관계는 순서 없는 튜플(tuple) 모음 (SQL의 row)


--------------------------------------------------
2. NoSQL의 탄생
--------------------------------------------------

* 2010년대 NoSQL은 관계형 모델의 우위를 뒤집으려는 시도

[NoSQL 채택 주요 동기]
- 뛰어난 확장성 요구
  -> 대규모 데이터셋, 높은 쓰기 처리량
- 상용 DB보다 무료 오픈소스 선호 확산
- 관계형 모델에서 지원하지 않는 특수 질의
- 엄격한 스키마에 대한 불만
- 더 동적이고 표현력 풍부한 데이터 모델에 대한 요구


--------------------------------------------------
3. 객체-관계형 불일치 (Impedance Mismatch)
--------------------------------------------------

* 대부분의 애플리케이션은 객체지향 언어로 개발
* 관계형 DB의 SQL 모델과 자연스럽게 맞지 않음

[문제점]
- 객체 ↔ 테이블 간 전환 계층 필요
- 코드와 DB 모델 사이에 반복적인 매핑 발생

[예시]
- MyBatis 수동 매핑
- DB 컬럼명: disp_ctg_id
- Java 필드명: dispCtgId

* 설정으로 자동화 가능하지만
  -> 불일치 자체가 사라지는 것은 아님
* DTO가 테이블과 1:1 매핑되지 않는 경우도 매우 많음


--------------------------------------------------
4. ORM의 한계
--------------------------------------------------

* ActiveRecord, Hibernate 같은 ORM
  -> boilerplate code 감소

하지만,
* 객체 모델과 관계형 모델은 근본적으로 다름
* 완벽하게 차이를 숨길 수는 없음

[관계형 DB의 대응]
- SQL 표준에 구조화된 데이터 타입, XML 지원 추가
- MySQL, PostgreSQL 등에서 JSON 타입 지원

-> 객체 모델을 완전히 반영한다기보다는
   유연성을 높이기 위한 대응에 가까움


==================================================
다대일 / 다대다 관계
==================================================

--------------------------------------------------
5. 다대일 관계
--------------------------------------------------

* 평문 대신 ID 사용
  ex) region_id, industry_id

[관계형 DB의 장점]
- 데이터 일관성 유지
- 모호성 회피 (동일 이름 도시 문제)
- 갱신 용이
- 현지화 지원
- 검색에 유리


--------------------------------------------------
6. 문서 모델에서의 한계
--------------------------------------------------

* 중복 제거(정규화)를 위해 다대일 관계 필요
* 문서 모델은 다대일, 다대다 관계에 취약

[이유]
- 조인 지원이 약함
- 다중 질의를 애플리케이션 코드에서 처리해야 함

[결과]
- 복잡도가 DB → 애플리케이션으로 이동
- 기능이 늘수록 데이터 간 연결 증가
- 다대다 관계가 생기며 구조 복잡

[예시]
- 최근 본 브랜드 정보 조회
- MongoDB에서 최근 본 상품 조회
- 애플리케이션에서 join 흉내
- 브랜드 정보 추가 조회


==================================================
문서 DB는 역사를 반복하는가?
==================================================

--------------------------------------------------
7. 계층 모델 (IMS)
--------------------------------------------------

* 1970년대 IBM IMS
* 계층 모델 사용

[특징]
- JSON과 유사한 트리 구조
- 일대다 관계에 적합
- 다대다 관계 표현 어려움
- 조인 미지원

-> 데이터 중복 or 수동 참조 선택 필요


--------------------------------------------------
8. 네트워크 모델 (CODASYL)
--------------------------------------------------

* 계층 모델의 일반화

[차이점: 부모 노드 수]
- 계층 모델
  -> 부모는 정확히 하나
  -> 트리 구조
- 네트워크 모델
  -> 다중 부모 허용
  -> 다대일, 다대다 표현 가능

[특징]
- 외래키 대신 포인터 기반 연결
- 루트 레코드부터 접근 경로를 따라 탐색


--------------------------------------------------
9. 수동 접근 경로 문제
--------------------------------------------------

* 다양한 경로가 하나의 레코드로 연결됨
* 개발자가 접근 경로를 직접 관리해야 함

[예시]
- MongoDB hint 수동 지정
- MongoCategoryItemIndexService.java

vs
- 관계형 DB
- 쿼리 최적화기가 자동으로 최적 경로 선택


--------------------------------------------------
10. 네트워크 모델의 성능 이점
--------------------------------------------------

Q. 왜 성능이 좋았는가?

[이유]
- 포인터 기반 접근
- 탐색 없이 바로 다음 레코드 접근 가능

[배경]
- 디스크 I/O가 매우 비싸던 시절
- 탐색 비용 최소화 → 큰 성능 이점

[단점]
- 코드 복잡
- 유연성 부족


--------------------------------------------------
11. 관계형 모델의 핵심 차이
--------------------------------------------------

* 관계는 단순한 로우의 집합
* 접근 경로를 개발자가 신경 쓰지 않음

[쿼리 최적화기]
- 실행 순서
- 사용 인덱스
- 조인 방식 자동 결정

-> 접근 경로를 시스템이 책임짐


==================================================
관계형 DB vs 문서 DB
==================================================

--------------------------------------------------
12. 각 모델을 선호하는 이유
--------------------------------------------------

[문서 DB]
- 스키마 유연성
- 데이터 지역성
- 애플리케이션 구조와 유사

[관계형 DB]
- 조인에 강함
- 다대일 / 다대다 관계에 적합


--------------------------------------------------
13. 문서 모델의 단점
--------------------------------------------------

- 중첩 필드 직접 참조 어려움
- 깊은 경로 접근 필요
- 조인 미흡

* 요구사항에 따라 문제가 될 수도, 아닐 수도 있음

[예시]
- 이벤트 로그 시스템
  -> 조인 불필요


--------------------------------------------------
14. 문서 모델의 장점 1: 스키마 유연성
--------------------------------------------------

* JSON은 스키마를 강요하지 않음
* 임의의 키/값 추가 가능

[중요]
- 문서 DB는 schemaless
- 실제로는 암묵적 스키마 존재
- DB는 이를 강요하지 않음

[비교]
- 쓰기 스키마 (RDB): schema-on-write
- 읽기 스키마 (문서 DB): schema-on-read

ex)
- ReviewCollectionDto
- Map 기반 구조
- 읽을 때만 해석


--------------------------------------------------
15. 문서 모델의 장점 2: 데이터 지역성
--------------------------------------------------

* 전체 문서를 자주 읽는 경우 성능 이점
* 관련 데이터를 한 문서에 묶어 저장

vs 관계형 DB
- 다중 테이블
- 다중 인덱스 탐색
- 더 많은 디스크 접근


--------------------------------------------------
16. 모델 간 통합 흐름
--------------------------------------------------

* RDB → JSON, XML 지원 증가
* 문서 DB → 조인 기능 보강

-> 서로의 단점을 보완하는 방향


==================================================
데이터를 위한 질의 언어
==================================================

--------------------------------------------------
17. 선언형 질의 언어
--------------------------------------------------

* SQL, 관계 대수

[특징]
- 무엇을 원하는지만 표현
- 어떻게 수행할지는 시스템이 결정
- 병렬 실행에 유리
- 구현 변경 없이 성능 개선 가능


--------------------------------------------------
18. 명령형 언어
--------------------------------------------------

* 일반 프로그래밍 언어
* IMS, CODASYL

[특징]
- 실행 순서를 명시
- 병렬 처리 어려움


--------------------------------------------------
19. 웹에서의 선언형 접근
--------------------------------------------------

[예시]
- 페이지 제목을 파란 배경으로 강조

CSS (선언형)
- 선택자만 지정

JavaScript (명령형)
- DOM API 사용
- 코드 복잡

-> DB에서도 동일한 결론
   선언형 질의가 더 유리


--------------------------------------------------
20. 맵리듀스(MapReduce)
--------------------------------------------------

* 대규모 데이터 처리를 위한 모델
* 일부 NoSQL DB에서 지원
* 읽기 전용 질의에 사용

[특징]
- 선언형과 명령형의 중간
- map / reduce 함수 기반

[제약]
- 순수 함수
- 부수 효과 없음
- 추가 DB 질의 불가

-> 장애 발생 시 재실행 가능


==================================================
그래프형 데이터 모델
==================================================

--------------------------------------------------
21. 그래프 기본 개념
--------------------------------------------------

* 정점(Vertex)
- ID
- 유입/유출 간선
- 속성

* 간선(Edge)
- ID
- 시작 정점
- 끝 정점
- 관계 레이블
- 속성


--------------------------------------------------
22. 사이퍼(Cypher)
--------------------------------------------------

* 속성 그래프용 선언형 질의 언어
* Neo4j에서 사용


--------------------------------------------------
23. SQL로 그래프 질의하기
--------------------------------------------------

* 가능하지만 매우 어려움
* 조인 수를 미리 알 수 없음
* 가변 경로 탐색 필요


--------------------------------------------------
24. 트리플 저장소와 SPARQL
--------------------------------------------------

* (주어, 서술어, 목적어) 구조
* RDF 기반
* 시멘틱 웹을 위한 데이터 표현

SPARQL
- RDF 트리플 저장소 질의 언어


--------------------------------------------------
25. 데이터로그
--------------------------------------------------

* 가장 오래된 논리 기반 질의 언어
* 사실과 규칙 선언
* 시스템이 자동 추론 수행

-> 사이퍼, SPARQL의 초석


==================================================
회고
==================================================

* 카테고리 도메인은 다양한 모델을 포함
- 계층 구조
- graphLookup 활용
- 다대다 관계
- 수동 접근 제어

* 정답은 없음
* 각 모델의 특성을 이해하고
  요구사항에 맞게 선택하는 것이 중요

* 당장은 자주 쓰지 않더라도
  개념을 알고 있는 것만으로도 충분한 가치가 있음
