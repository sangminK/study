==================================================
3장 저장소와 검색
==================================================

--------------------------------------------------
1. 데이터베이스의 기본 수행 작업
--------------------------------------------------

데이터베이스의 핵심 역할은 크게 두 가지다.

* 데이터를 저장한다
* 데이터를 제공한다

개발자가 특정 작업 부하(workload) 유형에서
좋은 성능을 내도록 저장소 엔진을 조정하려면,
저장소 엔진 내부에서 어떤 작업이 수행되는지에 대해
대략적인 개념을 이해할 필요가 있다.


==================================================
데이터베이스를 강력하게 만드는 데이터 구조
==================================================

--------------------------------------------------
2. 색인(Index)의 필요성
--------------------------------------------------

DB에서 특정 키의 값을 효율적으로 찾기 위해서는
색인이라는 별도의 데이터 구조가 필요하다.

* 색인이 없다면 검색 비용은 O(n)
* 데이터가 커질수록 성능은 급격히 저하됨

색인의 일반적인 개념은
"부가적인 메타데이터(metadata)를 유지하는 것"

메타데이터는 이정표 역할을 하여
원하는 데이터의 위치를 빠르게 찾도록 돕는다.

* 동일한 데이터를 다양한 방식으로 검색하려면
  → 여러 개의 색인이 필요
* 색인은 기본 데이터(primary data)에서 파생된 추가 구조


--------------------------------------------------
3. 색인의 트레이드오프
--------------------------------------------------

* 대부분의 DB는 색인의 추가 / 삭제를 허용
* 색인은 DB의 내용 자체에는 영향 없음
  → 질의 성능에만 영향

하지만,

* 색인은 쓰기 성능을 저하시킴
  → 데이터를 쓸 때마다 색인도 갱신해야 하기 때문

→ 저장소 시스템의 핵심 트레이드오프

결론:
* 모든 것을 색인하지 말 것
* 필요 없는 색인은 오버헤드만 증가
* 적절한 수동 선택이 중요


==================================================
해시 색인 (Hash Index)
==================================================

--------------------------------------------------
4. 해시 색인의 개념
--------------------------------------------------

키-값 저장소는
프로그래밍 언어의 사전(dictionary) 타입과 매우 유사하다.

보통 내부 구현은
* 해시 맵(Hash Map)
* 해시 테이블(Hash Table)


--------------------------------------------------
5. 로그 구조 저장 방식 (Bitcask)
--------------------------------------------------

이 책에서 말하는 로그(log)는
"연속된 추가 전용 레코드"를 의미한다.


[저장 구조]
- 키-값 데이터를 로그 파일에 순차적으로 기록 (append-only)
- 메모리 해시맵:
  키 → 로그 파일의 바이트 오프셋 저장

[읽기 흐름]
1. 메모리 해시맵에서 오프셋 조회
2. 디스크에서 해당 위치를 바로 읽음

→ 매우 빠름


[장점]
- 구조가 단순
- 디스크 탐색 최소화
- 빠른 읽기 / 쓰기
- 모든 키를 RAM에 저장하여 빠른 lookup


[활용 사례]
- 키는 거의 변하지 않지만
- 값은 자주 갱신되는 경우
  ex) 조회수, 카운터


--------------------------------------------------
6. 로그 구조의 문제점과 해결
--------------------------------------------------

[문제]
- 로그에 오래된 값이 계속 누적
- 파일 크기 무한 증가

[해결: Compaction]
- 로그 파일을 세그먼트(segment)로 분리
- 주기적으로 컴팩션 수행
- 오래된 값 제거
- 각 키의 최신 값만 남김

→ 디스크 공간 절약 + 성능 유지

정리:
Bitcask는
"append-only 로그 + 메모리 해시맵" 구조로
빠르고 단순한 키-값 저장 방식이다.


--------------------------------------------------
7. 추가 전용 로그의 장점
--------------------------------------------------

언뜻 보면 낭비처럼 보이지만,
추가 전용 로그는 매우 좋은 설계다.

* 순차 쓰기 → 무작위 쓰기보다 훨씬 빠름
* 세그먼트가 불변이면 동시성 처리 단순
* 장애 발생 시 중간 상태 걱정 없음
* 병합으로 파일 조각화 문제 회피


--------------------------------------------------
8. 해시 테이블 색인의 한계
--------------------------------------------------

* 해시 테이블은 메모리에 저장해야 함
  → 키가 많아지면 문제 발생

디스크 해시 맵이 비효율적인 이유:
- 무작위 접근 I/O 과다
- 디스크 확장 비용 큼
- 해시 충돌 처리 로직 복잡

또한,
* 범위 질의(range query)에 부적합
  → 모든 키를 조회해야 함


==================================================
SS테이블과 LSM 트리
==================================================

--------------------------------------------------
9. SS테이블 (Sorted String Table)
--------------------------------------------------

SS테이블은
키-값 데이터를 "정렬된 상태로"
디스크에 저장한 파일 형식이다.

* Sorted : 키 정렬
* String : 키를 문자열처럼 취급
* Table  : 키-값 쌍 집합

핵심 아이디어:
"디스크에는 정렬된 상태로,
 한 번에 쭉 쓰고 쭉 읽자"


--------------------------------------------------
10. SS테이블의 장점
--------------------------------------------------

[세그먼트 병합]
- 병합 정렬(mergesort) 방식
- 메모리보다 큰 파일도 효율적으로 병합 가능

[색인 관리]
- 모든 키를 메모리에 유지할 필요 없음

[압축]
- 레코드를 블록 단위로 묶어 압축
- 디스크 공간 절약
- I/O 대역폭 감소


--------------------------------------------------
11. 해시 테이블 vs SS테이블
--------------------------------------------------

저장 위치
- 해시 테이블 : 메모리 중심
- SS테이블   : 디스크 중심

동등 조회 (=)
- 해시 테이블 : 매우 빠름
- SS테이블   : 빠름

범위 조회
- 해시 테이블 : 불가
- SS테이블   : 가능

디스크 친화성
- 해시 테이블 : 낮음
- SS테이블   : 높음

수정/삭제
- 해시 테이블 : 쉬움
- SS테이블   : 직접 수정 불가

사용 예
- 해시 테이블 : 캐시
- SS테이블   : 대용량 저장


--------------------------------------------------
12. SS테이블 생성과 유지
--------------------------------------------------

[쓰기]
- 쓰기 요청 → 인메모리 균형 트리 저장
- 이 구조를 멤테이블(memtable)이라 부름

[Flush]
- 멤테이블이 커지면
- SS테이블로 디스크에 기록

[읽기]
1. 멤테이블 검색
2. 최신 SS테이블부터 순차 탐색

[문제]
- SS테이블이 많아질수록 읽기 성능 저하

[해결]
- 백그라운드 병합 + 컴팩션

→ 이 구조를
LSM(Log-Structured Merge) 트리라 부름


==================================================
B-트리
==================================================

--------------------------------------------------
13. B-트리 개요
--------------------------------------------------

B-트리는
가장 널리 사용되는 색인 구조다.

* 대부분의 관계형 DB에서 표준
* 많은 비관계형 DB에서도 사용
* 키 정렬 유지
* 동등 조회 + 범위 질의 모두 효율적


--------------------------------------------------
14. B-트리의 구조
--------------------------------------------------

* 고정 크기 페이지(page) 단위
* 페이지는 디스크 블록에 대응
* 루트 → 내부 페이지 → 리프 페이지

[분기 계수]
- 한 페이지가 가질 수 있는 하위 페이지 수
- 수십~수백 개
- 트리 높이가 매우 낮음
- 보통 3~4번 디스크 접근


--------------------------------------------------
15. 페이지 분할 (Insert)
--------------------------------------------------

[기본]
- 리프 페이지에 키 삽입
- 정렬 상태 유지

[페이지가 꽉 찬 경우]
- 페이지 분할
- 키를 반으로 나눔
- 부모 페이지에 경계 키 추가
- 필요 시 루트까지 전파

정리:
B-트리는
"페이지 단위로 내려가며,
 가득 차면 반으로 나누는"
디스크 친화적 균형 트리다.


==================================================
B-트리 최적화 기법
==================================================

--------------------------------------------------
16. 주요 최적화
--------------------------------------------------

* Copy-on-Write
  - 페이지 수정 대신 새 페이지 생성
  - WAL 불필요
  - 스냅샷 구현 용이

* 키 축약(Key Prefix Compression)
  - 내부 노드는 경계만 저장
  - 분기 계수 증가
  - 트리 높이 감소

* 리프 페이지 포인터 (B+트리)
  - 리프를 연결 리스트로 연결
  - 범위 스캔 성능 향상

* 프랙탈 트리
  - 내부 노드에 로그 버퍼
  - 쓰기 성능 개선


--------------------------------------------------
17. B-트리 vs LSM 트리
--------------------------------------------------

쓰기
- B-트리 : 느림
- LSM    : 빠름

읽기
- B-트리 : 빠름
- LSM    : 느릴 수 있음

디스크 I/O
- B-트리 : 랜덤
- LSM    : 순차

구조 변경
- B-트리 : 페이지 분할
- LSM    : 컴팩션


==================================================
OLTP와 OLAP
==================================================

--------------------------------------------------
18. OLTP
--------------------------------------------------

* 온라인 트랜잭션 처리
* 짧은 질의
* 적은 수의 레코드 접근
* 삽입 / 갱신 중심


--------------------------------------------------
19. OLAP
--------------------------------------------------

* 온라인 분석 처리
* 대량 스캔
* 집계 중심
* 분석 질의


--------------------------------------------------
20. 데이터 웨어하우스
--------------------------------------------------

* OLTP 시스템의 읽기 전용 복사본
* 분석 전용 DB
* ETL 과정 수행
* 분석 친화적 스키마 사용


==================================================
분석용 스키마
==================================================

--------------------------------------------------
21. 별 모양 스키마
--------------------------------------------------

* 하나의 팩트 테이블
* 여러 차원 테이블
* 조인 수 적음
* 조회 성능 우수
* 구조 단순


--------------------------------------------------
22. 눈꽃송이 스키마
--------------------------------------------------

* 차원 테이블 정규화
* 중복 감소
* 조인 수 증가
* 구조 복잡


==================================================
칼럼 지향 저장소
==================================================

--------------------------------------------------
23. 칼럼 저장의 특징
--------------------------------------------------

* 열(column) 단위 저장
* 압축 효율 극대화
* 대량 분석에 최적


--------------------------------------------------
24. 압축 기법
--------------------------------------------------

- Run-Length Encoding
- Dictionary Encoding
- Delta Encoding
- Bit-Packing

→ 디스크 I/O 감소
→ CPU 캐시 효율 증가


--------------------------------------------------
25. 정렬과 데이터 스킵
--------------------------------------------------

* 칼럼 기준 정렬
* 블록별 최소/최대값 메타데이터
* 조건에 맞지 않는 블록 스킵


--------------------------------------------------
26. 칼럼 저장소의 쓰기
--------------------------------------------------

* 쓰기 성능 약점
* 배치 쓰기 중심
* 델타 스토어 + 백그라운드 병합

정리:
- OLAP에 최적
- OLTP에는 부적합


==================================================
회고
==================================================

* 색인은 항상 트레이드오프
* 쓰기 / 읽기 / 공간 비용 고려 필수
* 워크로드에 맞는 구조 선택이 중요
